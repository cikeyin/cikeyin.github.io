{"remainingRequest":"D:\\项目\\个人网站\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!D:\\项目\\个人网站\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\项目\\个人网站\\node_modules\\vue-loader\\lib\\index.js??ref--1-1!D:\\项目\\个人网站\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js??ref--1-2!D:\\项目\\个人网站\\docs\\blog\\promise.md?vue&type=template&id=44950f16&","dependencies":[{"path":"D:\\项目\\个人网站\\docs\\blog\\promise.md","mtime":1552560533518},{"path":"D:\\项目\\个人网站\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\项目\\个人网站\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"D:\\项目\\个人网站\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\项目\\个人网站\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\项目\\个人网站\\node_modules\\vuepress\\lib\\webpack\\markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h3 id=\\\"promise原理与实现\\\"><a href=\\\"#promise原理与实现\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Promise原理与实现</h3> <h4 id=\\\"一、promise是什么？\\\"><a href=\\\"#一、promise是什么？\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 一、Promise是什么？</h4> <p>Promise是一种异步编程解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。</p> <ul><li><p>从语法上讲，promise是一个对象，从它可以获取异步操作的消息。</p></li> <li><p>promise有三种状态：pending、fulfiled、rejected，状态一旦改变，就不会再变。</p></li> <li><p>创造promise实例后，它会立即执行。</p></li> <li><p>Promise可以解决异步问题，但是不能说Promise是异步的。</p></li></ul> <h4 id=\\\"二、几种常见的异步解决方案\\\"><a href=\\\"#二、几种常见的异步解决方案\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 二、几种常见的异步解决方案</h4> <ul><li><p>回调函数</p></li> <li><p>事件监听</p></li> <li><p>发布/订阅</p></li> <li><p>Promise对象</p></li></ul> \"),_vm._ssrNode(\"<blockquote>\",\"</blockquote>\",[_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"参考： \"),_vm._ssrNode(\"<a href=\\\"http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"四种异步编程方案\"),_c('OutboundLink')],2)],2)]),_vm._ssrNode(\" <h4 id=\\\"三、promise解决的痛点\\\"><a href=\\\"#三、promise解决的痛点\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 三、Promise解决的痛点</h4> <p>处理多个相互关联的异步请求，回调嵌套很多时，出现 <strong>毁掉地狱</strong> 的情况，这种编码模式有以下问题：</p> <ul><li><p>多级嵌套导致代码繁杂，不利于阅读与维护</p></li> <li><p>异步操作顺序变更时，需要大规模的代码重构</p></li> <li><p>回调函数基本都是匿名函数，bug追踪困难</p></li></ul> <h4 id=\\\"四、promise使用\\\"><a href=\\\"#四、promise使用\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 四、Promise使用</h4> <ol><li>Promise构造函数</li></ol> <p>Promise 是一个构造函数，new Promise 返回一个 promise对象，接收一个excutor执行函数作为参数。</p> <p>executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。</p> <p>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p> <div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">const</span> promise <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">,</span> reject<span class=\\\"token punctuation\\\">)</span><span class=\\\"token operator\\\">=&gt;</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">//异步处理  </span>\\n    <span class=\\\"token comment\\\">//处理结束后，调用resolve或reject </span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><ol start=\\\"2\\\"><li>promise对象方法</li></ol> <p>（1）then方法 当resolve或reject时的回调函数</p> <div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code>promise<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span>onFulfilled<span class=\\\"token punctuation\\\">,</span>onRejected<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><blockquote><p>注意：then方法是异步执行的</p></blockquote> <p>（2）resolve时onFulfilled被调用</p> <div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">const</span> promise <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">,</span> reject<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token function\\\">resolve</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'fulfilled'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 状态由 pending =&gt; fulfilled</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\npromise<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span>result <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// onFulfilled</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>result<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 'fulfilled' </span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> reason <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// onRejected 不会被调用</span>\\n    \\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><p>（3）reject时onRejected被调用</p> <div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code>onst promise <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Promise</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>resolve<span class=\\\"token punctuation\\\">,</span> reject<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token function\\\">reject</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'rejected'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 状态由 pending =&gt; rejected</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\npromise<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span>result <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// onFulfilled 不会被调用</span>\\n  \\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span> reason <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// onRejected </span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>reason<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 'rejected'</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><p>(4) promise.catch</p> <p>在链式写法中可以捕获前面then中发送的异常</p> <div class=\\\"language-js extra-class\\\"><pre class=\\\"language-js\\\"><code>promise<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">catch</span><span class=\\\"token punctuation\\\">(</span>onRejected<span class=\\\"token punctuation\\\">)</span>\\n相当于\\npromise<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">then</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span> onRrejected<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><ol start=\\\"2\\\"><li>promise chain</li></ol> <p>promise.then方法每次调用,都返回一个新的promise对象,所以可以链式写法</p> <ol start=\\\"3\\\"><li>Promise的静态方法</li></ol> <p>（1） Promise.resolve 返回一个fulfilled状态的promise对象。</p> <p>（2） Promise.reject 返回一个rejected状态的promise对象。</p> <p>（3） Promise.all 接收一个promise对象数组为参数，只有全部为resolve才会调用，通常会用来处理多个并行异步操作。</p> <p>（4） Promise.race 接收一个promise对象数组为参数，Promise.rac 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p> <h4 id=\\\"五、手写一个promise\\\"><a href=\\\"#五、手写一个promise\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 五、手写一个Promise</h4> <h4 id=\\\"六、回调转换为promise\\\"><a href=\\\"#六、回调转换为promise\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 六、回调转换为Promise</h4> \"),_vm._ssrNode(\"<blockquote>\",\"</blockquote>\",[_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"参考：<br> \"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5aa7868b6fb9a028dd4de672#heading-4\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"面试精选之Promise\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5b31a4b7f265da595725f322#heading-6\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"Promise原理讲解 &amp;&amp; 实现一个Promise对象 \"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/597724c26fb9a06bb75260e8\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"八段代码彻底掌握 Promise\"),_c('OutboundLink')],2),_vm._ssrNode(\"<br> \"),_vm._ssrNode(\"<a href=\\\"https://juejin.im/post/5afe6d3bf265da0b9e654c4b\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"史上最通俗易懂的Promise\"),_c('OutboundLink')],2)],2)])],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}