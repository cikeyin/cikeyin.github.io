<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise原理与实现 | 刺客的主页</title>
    <meta name="description" content="刺客的主页 技术博客">
    <link rel="icon" href="/Blog/favicon.ico">
    
    <link rel="preload" href="/Blog/assets/css/0.styles.f1b0328c.css" as="style"><link rel="preload" href="/Blog/assets/js/app.53316db4.js" as="script"><link rel="preload" href="/Blog/assets/js/9.d854a588.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.5166443d.js"><link rel="prefetch" href="/Blog/assets/js/11.30a3e37c.js"><link rel="prefetch" href="/Blog/assets/js/12.ce1e94ad.js"><link rel="prefetch" href="/Blog/assets/js/2.f322ea4b.js"><link rel="prefetch" href="/Blog/assets/js/3.01e0aa4f.js"><link rel="prefetch" href="/Blog/assets/js/4.1882d018.js"><link rel="prefetch" href="/Blog/assets/js/5.d7247d01.js"><link rel="prefetch" href="/Blog/assets/js/6.6b5a21a1.js"><link rel="prefetch" href="/Blog/assets/js/7.ba8ff3b7.js"><link rel="prefetch" href="/Blog/assets/js/8.d76e960c.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.f1b0328c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">刺客的主页</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">介绍</a></div><div class="nav-item"><a href="/Blog/blog/reg.html" class="nav-link">技术总结</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">介绍</a></div><div class="nav-item"><a href="/Blog/blog/reg.html" class="nav-link">技术总结</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Blog/blog/reg.html" class="sidebar-link">正则表达式</a></li><li><a href="/Blog/blog/markdown.html" class="sidebar-link">Markdown语法</a></li><li><a href="/Blog/blog/browserCache.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/Blog/blog/eventLoop.html" class="sidebar-link">JavaScript事件循环机制（Event Loop）</a></li><li><a href="/Blog/blog/promise.html" class="active sidebar-link">Promise原理与实现</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Blog/blog/algorithm.html" class="sidebar-link">前端算法</a></li><li><a href="/Blog/blog/callApply.html" class="sidebar-link">call、apply、bind</a></li></ul> </div> <div class="page"> <div class="content"><h3 id="promise原理与实现"><a href="#promise原理与实现" aria-hidden="true" class="header-anchor">#</a> Promise原理与实现</h3> <h4 id="一、promise是什么？"><a href="#一、promise是什么？" aria-hidden="true" class="header-anchor">#</a> 一、Promise是什么？</h4> <p>Promise是一种异步编程解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。</p> <ul><li><p>从语法上讲，promise是一个对象，从它可以获取异步操作的消息。</p></li> <li><p>promise有三种状态：pending、fulfiled、rejected，状态一旦改变，就不会再变。</p></li> <li><p>创造promise实例后，它会立即执行。</p></li> <li><p>Promise可以解决异步问题，但是不能说Promise是异步的。</p></li></ul> <h4 id="二、几种常见的异步解决方案"><a href="#二、几种常见的异步解决方案" aria-hidden="true" class="header-anchor">#</a> 二、几种常见的异步解决方案</h4> <ul><li><p>回调函数</p></li> <li><p>事件监听</p></li> <li><p>发布/订阅</p></li> <li><p>Promise对象</p></li></ul> <blockquote><p>参考： <a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener noreferrer">四种异步编程方案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h4 id="三、promise解决的痛点"><a href="#三、promise解决的痛点" aria-hidden="true" class="header-anchor">#</a> 三、Promise解决的痛点</h4> <p>处理多个相互关联的异步请求，回调嵌套很多时，出现 <strong>毁掉地狱</strong> 的情况，这种编码模式有以下问题：</p> <ul><li><p>多级嵌套导致代码繁杂，不利于阅读与维护</p></li> <li><p>异步操作顺序变更时，需要大规模的代码重构</p></li> <li><p>回调函数基本都是匿名函数，bug追踪困难</p></li></ul> <h4 id="四、promise使用"><a href="#四、promise使用" aria-hidden="true" class="header-anchor">#</a> 四、Promise使用</h4> <ol><li>Promise构造函数</li></ol> <p>Promise 是一个构造函数，new Promise 返回一个 promise对象，接收一个excutor执行函数作为参数。</p> <p>executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。</p> <p>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//异步处理  </span>
    <span class="token comment">//处理结束后，调用resolve或reject </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>promise对象方法</li></ol> <p>（1）then方法 当resolve或reject时的回调函数</p> <div class="language-js extra-class"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>注意：then方法是异步执行的</p></blockquote> <p>（2）resolve时onFulfilled被调用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'fulfilled'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态由 pending =&gt; fulfilled</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onFulfilled</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'fulfilled' </span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onRejected 不会被调用</span>
    
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>（3）reject时onRejected被调用</p> <div class="language-js extra-class"><pre class="language-js"><code>onst promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态由 pending =&gt; rejected</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onFulfilled 不会被调用</span>
  
<span class="token punctuation">}</span><span class="token punctuation">,</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// onRejected </span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'rejected'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>(4) promise.catch</p> <p>在链式写法中可以捕获前面then中发送的异常</p> <div class="language-js extra-class"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
相当于
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> onRrejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>promise chain</li></ol> <p>promise.then方法每次调用,都返回一个新的promise对象,所以可以链式写法</p> <ol start="3"><li>Promise的静态方法</li></ol> <p>（1） Promise.resolve 返回一个fulfilled状态的promise对象。</p> <p>（2） Promise.reject 返回一个rejected状态的promise对象。</p> <p>（3） Promise.all 接收一个promise对象数组为参数，只有全部为resolve才会调用，通常会用来处理多个并行异步操作。</p> <p>（4） Promise.race 接收一个promise对象数组为参数，Promise.rac 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p> <h4 id="五、手写一个promise"><a href="#五、手写一个promise" aria-hidden="true" class="header-anchor">#</a> 五、手写一个Promise</h4> <h4 id="六、回调转换为promise"><a href="#六、回调转换为promise" aria-hidden="true" class="header-anchor">#</a> 六、回调转换为Promise</h4> <blockquote><p>参考：<br> <a href="https://juejin.im/post/5aa7868b6fb9a028dd4de672#heading-4" target="_blank" rel="noopener noreferrer">面试精选之Promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br> <a href="https://juejin.im/post/5b31a4b7f265da595725f322#heading-6" target="_blank" rel="noopener noreferrer">Promise原理讲解 &amp;&amp; 实现一个Promise对象 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br> <a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener noreferrer">八段代码彻底掌握 Promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br> <a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b" target="_blank" rel="noopener noreferrer">史上最通俗易懂的Promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Blog/blog/eventLoop.html" class="prev">
          JavaScript事件循环机制（Event Loop）
        </a></span> <span class="next"><a href="/Blog/blog/algorithm.html">
          前端算法
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/Blog/assets/js/app.53316db4.js" defer></script><script src="/Blog/assets/js/9.d854a588.js" defer></script>
  </body>
</html>
